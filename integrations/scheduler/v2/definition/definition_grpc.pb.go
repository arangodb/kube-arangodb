//
// DISCLAIMER
//
// Copyright 2024 ArangoDB GmbH, Cologne, Germany
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright holder is ArangoDB GmbH, Cologne, Germany
//

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.0
// source: integrations/scheduler/v2/definition/definition.proto

package definition

import (
	context "context"
	definition "github.com/arangodb/kube-arangodb/integrations/shared/v1/definition"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SchedulerV2_InvalidateCache_FullMethodName           = "/scheduler.SchedulerV2/InvalidateCache"
	SchedulerV2_Alive_FullMethodName                     = "/scheduler.SchedulerV2/Alive"
	SchedulerV2_List_FullMethodName                      = "/scheduler.SchedulerV2/List"
	SchedulerV2_Status_FullMethodName                    = "/scheduler.SchedulerV2/Status"
	SchedulerV2_StatusObjects_FullMethodName             = "/scheduler.SchedulerV2/StatusObjects"
	SchedulerV2_Install_FullMethodName                   = "/scheduler.SchedulerV2/Install"
	SchedulerV2_Upgrade_FullMethodName                   = "/scheduler.SchedulerV2/Upgrade"
	SchedulerV2_Uninstall_FullMethodName                 = "/scheduler.SchedulerV2/Uninstall"
	SchedulerV2_Test_FullMethodName                      = "/scheduler.SchedulerV2/Test"
	SchedulerV2_InstallV2_FullMethodName                 = "/scheduler.SchedulerV2/InstallV2"
	SchedulerV2_UpgradeV2_FullMethodName                 = "/scheduler.SchedulerV2/UpgradeV2"
	SchedulerV2_DiscoverAPIResources_FullMethodName      = "/scheduler.SchedulerV2/DiscoverAPIResources"
	SchedulerV2_DiscoverAPIResource_FullMethodName       = "/scheduler.SchedulerV2/DiscoverAPIResource"
	SchedulerV2_KubernetesGet_FullMethodName             = "/scheduler.SchedulerV2/KubernetesGet"
	SchedulerV2_KubernetesPermissionCheck_FullMethodName = "/scheduler.SchedulerV2/KubernetesPermissionCheck"
	SchedulerV2_ListCharts_FullMethodName                = "/scheduler.SchedulerV2/ListCharts"
	SchedulerV2_GetChart_FullMethodName                  = "/scheduler.SchedulerV2/GetChart"
)

// SchedulerV2Client is the client API for SchedulerV2 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Integration Service
type SchedulerV2Client interface {
	// Invalidates local ServiceDiscover cache
	InvalidateCache(ctx context.Context, in *definition.Empty, opts ...grpc.CallOption) (*definition.Empty, error)
	// Ensure that Helm Client is able to communicate with Kubernetes
	Alive(ctx context.Context, in *definition.Empty, opts ...grpc.CallOption) (*definition.Empty, error)
	// Executes Helm List Action
	List(ctx context.Context, in *SchedulerV2ListRequest, opts ...grpc.CallOption) (*SchedulerV2ListResponse, error)
	// Executes Helm Status Action
	Status(ctx context.Context, in *SchedulerV2StatusRequest, opts ...grpc.CallOption) (*SchedulerV2StatusResponse, error)
	// Executes Helm Status Action and fetch Resources from Kubernetes API
	StatusObjects(ctx context.Context, in *SchedulerV2StatusObjectsRequest, opts ...grpc.CallOption) (*SchedulerV2StatusObjectsResponse, error)
	// Executes Helm Install Action
	Install(ctx context.Context, in *SchedulerV2InstallRequest, opts ...grpc.CallOption) (*SchedulerV2InstallResponse, error)
	// Executes Helm Upgrade Action
	Upgrade(ctx context.Context, in *SchedulerV2UpgradeRequest, opts ...grpc.CallOption) (*SchedulerV2UpgradeResponse, error)
	// Executes Helm Uninstall Action
	Uninstall(ctx context.Context, in *SchedulerV2UninstallRequest, opts ...grpc.CallOption) (*SchedulerV2UninstallResponse, error)
	// Executes Helm Test Action
	Test(ctx context.Context, in *SchedulerV2TestRequest, opts ...grpc.CallOption) (*SchedulerV2TestResponse, error)
	// Executes Helm Install Action
	InstallV2(ctx context.Context, in *SchedulerV2InstallV2Request, opts ...grpc.CallOption) (*SchedulerV2InstallV2Response, error)
	// Executes Helm Upgrade Action
	UpgradeV2(ctx context.Context, in *SchedulerV2UpgradeV2Request, opts ...grpc.CallOption) (*SchedulerV2UpgradeV2Response, error)
	// Discovers Kubernetes API Resources for Group
	DiscoverAPIResources(ctx context.Context, in *SchedulerV2DiscoverAPIResourcesRequest, opts ...grpc.CallOption) (*SchedulerV2DiscoverAPIResourcesResponse, error)
	// Discovers Kubernetes API Resources for Kind
	DiscoverAPIResource(ctx context.Context, in *SchedulerV2DiscoverAPIResourceRequest, opts ...grpc.CallOption) (*SchedulerV2DiscoverAPIResourceResponse, error)
	// Gets Kubernetes objects from the API
	KubernetesGet(ctx context.Context, in *SchedulerV2KubernetesGetRequest, opts ...grpc.CallOption) (*SchedulerV2KubernetesGetResponse, error)
	// Checks if principal can take an action
	KubernetesPermissionCheck(ctx context.Context, in *SchedulerV2KubernetesPermissionCheckRequest, opts ...grpc.CallOption) (*SchedulerV2KubernetesPermissionCheckResponse, error)
	// Lists installed ArangoPlatform Charts
	ListCharts(ctx context.Context, in *SchedulerV2ListChartsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SchedulerV2ListChartsResponse], error)
	// Gets Installed ArangoDB Chart
	GetChart(ctx context.Context, in *SchedulerV2GetChartRequest, opts ...grpc.CallOption) (*SchedulerV2GetChartResponse, error)
}

type schedulerV2Client struct {
	cc grpc.ClientConnInterface
}

func NewSchedulerV2Client(cc grpc.ClientConnInterface) SchedulerV2Client {
	return &schedulerV2Client{cc}
}

func (c *schedulerV2Client) InvalidateCache(ctx context.Context, in *definition.Empty, opts ...grpc.CallOption) (*definition.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(definition.Empty)
	err := c.cc.Invoke(ctx, SchedulerV2_InvalidateCache_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) Alive(ctx context.Context, in *definition.Empty, opts ...grpc.CallOption) (*definition.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(definition.Empty)
	err := c.cc.Invoke(ctx, SchedulerV2_Alive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) List(ctx context.Context, in *SchedulerV2ListRequest, opts ...grpc.CallOption) (*SchedulerV2ListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2ListResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) Status(ctx context.Context, in *SchedulerV2StatusRequest, opts ...grpc.CallOption) (*SchedulerV2StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2StatusResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) StatusObjects(ctx context.Context, in *SchedulerV2StatusObjectsRequest, opts ...grpc.CallOption) (*SchedulerV2StatusObjectsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2StatusObjectsResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_StatusObjects_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) Install(ctx context.Context, in *SchedulerV2InstallRequest, opts ...grpc.CallOption) (*SchedulerV2InstallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2InstallResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_Install_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) Upgrade(ctx context.Context, in *SchedulerV2UpgradeRequest, opts ...grpc.CallOption) (*SchedulerV2UpgradeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2UpgradeResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_Upgrade_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) Uninstall(ctx context.Context, in *SchedulerV2UninstallRequest, opts ...grpc.CallOption) (*SchedulerV2UninstallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2UninstallResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_Uninstall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) Test(ctx context.Context, in *SchedulerV2TestRequest, opts ...grpc.CallOption) (*SchedulerV2TestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2TestResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_Test_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) InstallV2(ctx context.Context, in *SchedulerV2InstallV2Request, opts ...grpc.CallOption) (*SchedulerV2InstallV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2InstallV2Response)
	err := c.cc.Invoke(ctx, SchedulerV2_InstallV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) UpgradeV2(ctx context.Context, in *SchedulerV2UpgradeV2Request, opts ...grpc.CallOption) (*SchedulerV2UpgradeV2Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2UpgradeV2Response)
	err := c.cc.Invoke(ctx, SchedulerV2_UpgradeV2_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) DiscoverAPIResources(ctx context.Context, in *SchedulerV2DiscoverAPIResourcesRequest, opts ...grpc.CallOption) (*SchedulerV2DiscoverAPIResourcesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2DiscoverAPIResourcesResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_DiscoverAPIResources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) DiscoverAPIResource(ctx context.Context, in *SchedulerV2DiscoverAPIResourceRequest, opts ...grpc.CallOption) (*SchedulerV2DiscoverAPIResourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2DiscoverAPIResourceResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_DiscoverAPIResource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) KubernetesGet(ctx context.Context, in *SchedulerV2KubernetesGetRequest, opts ...grpc.CallOption) (*SchedulerV2KubernetesGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2KubernetesGetResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_KubernetesGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) KubernetesPermissionCheck(ctx context.Context, in *SchedulerV2KubernetesPermissionCheckRequest, opts ...grpc.CallOption) (*SchedulerV2KubernetesPermissionCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2KubernetesPermissionCheckResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_KubernetesPermissionCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerV2Client) ListCharts(ctx context.Context, in *SchedulerV2ListChartsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SchedulerV2ListChartsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &SchedulerV2_ServiceDesc.Streams[0], SchedulerV2_ListCharts_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SchedulerV2ListChartsRequest, SchedulerV2ListChartsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SchedulerV2_ListChartsClient = grpc.ServerStreamingClient[SchedulerV2ListChartsResponse]

func (c *schedulerV2Client) GetChart(ctx context.Context, in *SchedulerV2GetChartRequest, opts ...grpc.CallOption) (*SchedulerV2GetChartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerV2GetChartResponse)
	err := c.cc.Invoke(ctx, SchedulerV2_GetChart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchedulerV2Server is the server API for SchedulerV2 service.
// All implementations must embed UnimplementedSchedulerV2Server
// for forward compatibility.
//
// Integration Service
type SchedulerV2Server interface {
	// Invalidates local ServiceDiscover cache
	InvalidateCache(context.Context, *definition.Empty) (*definition.Empty, error)
	// Ensure that Helm Client is able to communicate with Kubernetes
	Alive(context.Context, *definition.Empty) (*definition.Empty, error)
	// Executes Helm List Action
	List(context.Context, *SchedulerV2ListRequest) (*SchedulerV2ListResponse, error)
	// Executes Helm Status Action
	Status(context.Context, *SchedulerV2StatusRequest) (*SchedulerV2StatusResponse, error)
	// Executes Helm Status Action and fetch Resources from Kubernetes API
	StatusObjects(context.Context, *SchedulerV2StatusObjectsRequest) (*SchedulerV2StatusObjectsResponse, error)
	// Executes Helm Install Action
	Install(context.Context, *SchedulerV2InstallRequest) (*SchedulerV2InstallResponse, error)
	// Executes Helm Upgrade Action
	Upgrade(context.Context, *SchedulerV2UpgradeRequest) (*SchedulerV2UpgradeResponse, error)
	// Executes Helm Uninstall Action
	Uninstall(context.Context, *SchedulerV2UninstallRequest) (*SchedulerV2UninstallResponse, error)
	// Executes Helm Test Action
	Test(context.Context, *SchedulerV2TestRequest) (*SchedulerV2TestResponse, error)
	// Executes Helm Install Action
	InstallV2(context.Context, *SchedulerV2InstallV2Request) (*SchedulerV2InstallV2Response, error)
	// Executes Helm Upgrade Action
	UpgradeV2(context.Context, *SchedulerV2UpgradeV2Request) (*SchedulerV2UpgradeV2Response, error)
	// Discovers Kubernetes API Resources for Group
	DiscoverAPIResources(context.Context, *SchedulerV2DiscoverAPIResourcesRequest) (*SchedulerV2DiscoverAPIResourcesResponse, error)
	// Discovers Kubernetes API Resources for Kind
	DiscoverAPIResource(context.Context, *SchedulerV2DiscoverAPIResourceRequest) (*SchedulerV2DiscoverAPIResourceResponse, error)
	// Gets Kubernetes objects from the API
	KubernetesGet(context.Context, *SchedulerV2KubernetesGetRequest) (*SchedulerV2KubernetesGetResponse, error)
	// Checks if principal can take an action
	KubernetesPermissionCheck(context.Context, *SchedulerV2KubernetesPermissionCheckRequest) (*SchedulerV2KubernetesPermissionCheckResponse, error)
	// Lists installed ArangoPlatform Charts
	ListCharts(*SchedulerV2ListChartsRequest, grpc.ServerStreamingServer[SchedulerV2ListChartsResponse]) error
	// Gets Installed ArangoDB Chart
	GetChart(context.Context, *SchedulerV2GetChartRequest) (*SchedulerV2GetChartResponse, error)
	mustEmbedUnimplementedSchedulerV2Server()
}

// UnimplementedSchedulerV2Server must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSchedulerV2Server struct{}

func (UnimplementedSchedulerV2Server) InvalidateCache(context.Context, *definition.Empty) (*definition.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvalidateCache not implemented")
}
func (UnimplementedSchedulerV2Server) Alive(context.Context, *definition.Empty) (*definition.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Alive not implemented")
}
func (UnimplementedSchedulerV2Server) List(context.Context, *SchedulerV2ListRequest) (*SchedulerV2ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedSchedulerV2Server) Status(context.Context, *SchedulerV2StatusRequest) (*SchedulerV2StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedSchedulerV2Server) StatusObjects(context.Context, *SchedulerV2StatusObjectsRequest) (*SchedulerV2StatusObjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatusObjects not implemented")
}
func (UnimplementedSchedulerV2Server) Install(context.Context, *SchedulerV2InstallRequest) (*SchedulerV2InstallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Install not implemented")
}
func (UnimplementedSchedulerV2Server) Upgrade(context.Context, *SchedulerV2UpgradeRequest) (*SchedulerV2UpgradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upgrade not implemented")
}
func (UnimplementedSchedulerV2Server) Uninstall(context.Context, *SchedulerV2UninstallRequest) (*SchedulerV2UninstallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uninstall not implemented")
}
func (UnimplementedSchedulerV2Server) Test(context.Context, *SchedulerV2TestRequest) (*SchedulerV2TestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Test not implemented")
}
func (UnimplementedSchedulerV2Server) InstallV2(context.Context, *SchedulerV2InstallV2Request) (*SchedulerV2InstallV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallV2 not implemented")
}
func (UnimplementedSchedulerV2Server) UpgradeV2(context.Context, *SchedulerV2UpgradeV2Request) (*SchedulerV2UpgradeV2Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpgradeV2 not implemented")
}
func (UnimplementedSchedulerV2Server) DiscoverAPIResources(context.Context, *SchedulerV2DiscoverAPIResourcesRequest) (*SchedulerV2DiscoverAPIResourcesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiscoverAPIResources not implemented")
}
func (UnimplementedSchedulerV2Server) DiscoverAPIResource(context.Context, *SchedulerV2DiscoverAPIResourceRequest) (*SchedulerV2DiscoverAPIResourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiscoverAPIResource not implemented")
}
func (UnimplementedSchedulerV2Server) KubernetesGet(context.Context, *SchedulerV2KubernetesGetRequest) (*SchedulerV2KubernetesGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KubernetesGet not implemented")
}
func (UnimplementedSchedulerV2Server) KubernetesPermissionCheck(context.Context, *SchedulerV2KubernetesPermissionCheckRequest) (*SchedulerV2KubernetesPermissionCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KubernetesPermissionCheck not implemented")
}
func (UnimplementedSchedulerV2Server) ListCharts(*SchedulerV2ListChartsRequest, grpc.ServerStreamingServer[SchedulerV2ListChartsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ListCharts not implemented")
}
func (UnimplementedSchedulerV2Server) GetChart(context.Context, *SchedulerV2GetChartRequest) (*SchedulerV2GetChartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChart not implemented")
}
func (UnimplementedSchedulerV2Server) mustEmbedUnimplementedSchedulerV2Server() {}
func (UnimplementedSchedulerV2Server) testEmbeddedByValue()                     {}

// UnsafeSchedulerV2Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SchedulerV2Server will
// result in compilation errors.
type UnsafeSchedulerV2Server interface {
	mustEmbedUnimplementedSchedulerV2Server()
}

func RegisterSchedulerV2Server(s grpc.ServiceRegistrar, srv SchedulerV2Server) {
	// If the following call pancis, it indicates UnimplementedSchedulerV2Server was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SchedulerV2_ServiceDesc, srv)
}

func _SchedulerV2_InvalidateCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(definition.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).InvalidateCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_InvalidateCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).InvalidateCache(ctx, req.(*definition.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_Alive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(definition.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).Alive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_Alive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).Alive(ctx, req.(*definition.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).List(ctx, req.(*SchedulerV2ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).Status(ctx, req.(*SchedulerV2StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_StatusObjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2StatusObjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).StatusObjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_StatusObjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).StatusObjects(ctx, req.(*SchedulerV2StatusObjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_Install_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2InstallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).Install(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_Install_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).Install(ctx, req.(*SchedulerV2InstallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_Upgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2UpgradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).Upgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_Upgrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).Upgrade(ctx, req.(*SchedulerV2UpgradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_Uninstall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2UninstallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).Uninstall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_Uninstall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).Uninstall(ctx, req.(*SchedulerV2UninstallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_Test_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2TestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).Test(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_Test_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).Test(ctx, req.(*SchedulerV2TestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_InstallV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2InstallV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).InstallV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_InstallV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).InstallV2(ctx, req.(*SchedulerV2InstallV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_UpgradeV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2UpgradeV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).UpgradeV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_UpgradeV2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).UpgradeV2(ctx, req.(*SchedulerV2UpgradeV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_DiscoverAPIResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2DiscoverAPIResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).DiscoverAPIResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_DiscoverAPIResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).DiscoverAPIResources(ctx, req.(*SchedulerV2DiscoverAPIResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_DiscoverAPIResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2DiscoverAPIResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).DiscoverAPIResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_DiscoverAPIResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).DiscoverAPIResource(ctx, req.(*SchedulerV2DiscoverAPIResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_KubernetesGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2KubernetesGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).KubernetesGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_KubernetesGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).KubernetesGet(ctx, req.(*SchedulerV2KubernetesGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_KubernetesPermissionCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2KubernetesPermissionCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).KubernetesPermissionCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_KubernetesPermissionCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).KubernetesPermissionCheck(ctx, req.(*SchedulerV2KubernetesPermissionCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerV2_ListCharts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SchedulerV2ListChartsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SchedulerV2Server).ListCharts(m, &grpc.GenericServerStream[SchedulerV2ListChartsRequest, SchedulerV2ListChartsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type SchedulerV2_ListChartsServer = grpc.ServerStreamingServer[SchedulerV2ListChartsResponse]

func _SchedulerV2_GetChart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulerV2GetChartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerV2Server).GetChart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchedulerV2_GetChart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerV2Server).GetChart(ctx, req.(*SchedulerV2GetChartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SchedulerV2_ServiceDesc is the grpc.ServiceDesc for SchedulerV2 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SchedulerV2_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "scheduler.SchedulerV2",
	HandlerType: (*SchedulerV2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InvalidateCache",
			Handler:    _SchedulerV2_InvalidateCache_Handler,
		},
		{
			MethodName: "Alive",
			Handler:    _SchedulerV2_Alive_Handler,
		},
		{
			MethodName: "List",
			Handler:    _SchedulerV2_List_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _SchedulerV2_Status_Handler,
		},
		{
			MethodName: "StatusObjects",
			Handler:    _SchedulerV2_StatusObjects_Handler,
		},
		{
			MethodName: "Install",
			Handler:    _SchedulerV2_Install_Handler,
		},
		{
			MethodName: "Upgrade",
			Handler:    _SchedulerV2_Upgrade_Handler,
		},
		{
			MethodName: "Uninstall",
			Handler:    _SchedulerV2_Uninstall_Handler,
		},
		{
			MethodName: "Test",
			Handler:    _SchedulerV2_Test_Handler,
		},
		{
			MethodName: "InstallV2",
			Handler:    _SchedulerV2_InstallV2_Handler,
		},
		{
			MethodName: "UpgradeV2",
			Handler:    _SchedulerV2_UpgradeV2_Handler,
		},
		{
			MethodName: "DiscoverAPIResources",
			Handler:    _SchedulerV2_DiscoverAPIResources_Handler,
		},
		{
			MethodName: "DiscoverAPIResource",
			Handler:    _SchedulerV2_DiscoverAPIResource_Handler,
		},
		{
			MethodName: "KubernetesGet",
			Handler:    _SchedulerV2_KubernetesGet_Handler,
		},
		{
			MethodName: "KubernetesPermissionCheck",
			Handler:    _SchedulerV2_KubernetesPermissionCheck_Handler,
		},
		{
			MethodName: "GetChart",
			Handler:    _SchedulerV2_GetChart_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListCharts",
			Handler:       _SchedulerV2_ListCharts_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "integrations/scheduler/v2/definition/definition.proto",
}
